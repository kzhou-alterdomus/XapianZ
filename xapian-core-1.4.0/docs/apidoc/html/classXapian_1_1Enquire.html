<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>Xapian: API Documentation: Xapian::Enquire Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceXapian.html">Xapian</a></li><li class="navelem"><a class="el" href="classXapian_1_1Enquire.html">Enquire</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classXapian_1_1Enquire-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Xapian::Enquire Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class provides an interface to the information retrieval system for the purpose of searching.  
 <a href="classXapian_1_1Enquire.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac451dc68045ec4b0d26f5b2a42eae2a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac451dc68045ec4b0d26f5b2a42eae2a9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#ac451dc68045ec4b0d26f5b2a42eae2a9">Enquire</a> (const <a class="el" href="classXapian_1_1Enquire.html">Enquire</a> &amp;other)</td></tr>
<tr class="memdesc:ac451dc68045ec4b0d26f5b2a42eae2a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copying is allowed (and is cheap). <br/></td></tr>
<tr class="memitem:a0c067ef5b6397ab064d09884efc06cbe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c067ef5b6397ab064d09884efc06cbe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a0c067ef5b6397ab064d09884efc06cbe">operator=</a> (const <a class="el" href="classXapian_1_1Enquire.html">Enquire</a> &amp;other)</td></tr>
<tr class="memdesc:a0c067ef5b6397ab064d09884efc06cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment is allowed (and is cheap). <br/></td></tr>
<tr class="memitem:a5a5197e96345339874b2138264320256"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a5a5197e96345339874b2138264320256">Enquire</a> (const <a class="el" href="classXapian_1_1Database.html">Database</a> &amp;database)</td></tr>
<tr class="memdesc:a5a5197e96345339874b2138264320256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose of searching...">Xapian::Enquire</a> object.  <a href="#a5a5197e96345339874b2138264320256"></a><br/></td></tr>
<tr class="memitem:a808479faae76453f34a24881805e75b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a808479faae76453f34a24881805e75b9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a808479faae76453f34a24881805e75b9">~Enquire</a> ()</td></tr>
<tr class="memdesc:a808479faae76453f34a24881805e75b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose of searching...">Xapian::Enquire</a> object. <br/></td></tr>
<tr class="memitem:a1148d960120662e5543e2a2b12620318"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a1148d960120662e5543e2a2b12620318">set_query</a> (const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a> &amp;query, <a class="el" href="namespaceXapian.html#a4464380f6fa0055b5f26b8d03ae170e2">Xapian::termcount</a> qlen=0)</td></tr>
<tr class="memdesc:a1148d960120662e5543e2a2b12620318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the query to run.  <a href="#a1148d960120662e5543e2a2b12620318"></a><br/></td></tr>
<tr class="memitem:add445bf19315638cccbb6418e2ae0d42"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#add445bf19315638cccbb6418e2ae0d42">get_query</a> () const </td></tr>
<tr class="memdesc:add445bf19315638cccbb6418e2ae0d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current query.  <a href="#add445bf19315638cccbb6418e2ae0d42"></a><br/></td></tr>
<tr class="memitem:a43b54489c53d26a98d3fde3f1d3aa14f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a43b54489c53d26a98d3fde3f1d3aa14f">add_matchspy</a> (<a class="el" href="classXapian_1_1MatchSpy.html">MatchSpy</a> *spy)</td></tr>
<tr class="memdesc:a43b54489c53d26a98d3fde3f1d3aa14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a matchspy.  <a href="#a43b54489c53d26a98d3fde3f1d3aa14f"></a><br/></td></tr>
<tr class="memitem:a1bb73406e3e7749a9e66ebc96ebd13f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bb73406e3e7749a9e66ebc96ebd13f3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a1bb73406e3e7749a9e66ebc96ebd13f3">clear_matchspies</a> ()</td></tr>
<tr class="memdesc:a1bb73406e3e7749a9e66ebc96ebd13f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all the matchspies. <br/></td></tr>
<tr class="memitem:ad5c72e6f34c5c2da5f0b8c79736704ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#ad5c72e6f34c5c2da5f0b8c79736704ab">set_weighting_scheme</a> (const <a class="el" href="classXapian_1_1Weight.html">Weight</a> &amp;weight_)</td></tr>
<tr class="memdesc:ad5c72e6f34c5c2da5f0b8c79736704ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the weighting scheme to use for queries.  <a href="#ad5c72e6f34c5c2da5f0b8c79736704ab"></a><br/></td></tr>
<tr class="memitem:ab6ee3bcb26e8a4974527805d9e85ea9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#ab6ee3bcb26e8a4974527805d9e85ea9d">set_expansion_scheme</a> (const std::string &amp;eweightname_, double expand_k_=1.0) const </td></tr>
<tr class="memdesc:ab6ee3bcb26e8a4974527805d9e85ea9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the weighting scheme to use for expansion.  <a href="#ab6ee3bcb26e8a4974527805d9e85ea9d"></a><br/></td></tr>
<tr class="memitem:a117ee547f5908e952e2e72d5a986d3bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a117ee547f5908e952e2e72d5a986d3bb">set_collapse_key</a> (<a class="el" href="namespaceXapian.html#a94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a> collapse_key, <a class="el" href="namespaceXapian.html#a9bbd62a8e56ea4619e4e59afb32aced6">Xapian::doccount</a> collapse_max=1)</td></tr>
<tr class="memdesc:a117ee547f5908e952e2e72d5a986d3bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the collapse key to use for queries.  <a href="#a117ee547f5908e952e2e72d5a986d3bb"></a><br/></td></tr>
<tr class="memitem:abbf7ff734ff6adcb301e493f6eed803b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#abbf7ff734ff6adcb301e493f6eed803b">set_docid_order</a> (docid_order order)</td></tr>
<tr class="memdesc:abbf7ff734ff6adcb301e493f6eed803b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the direction in which documents are ordered by document id in the returned <a class="el" href="classXapian_1_1MSet.html" title="Class representing a list of search results.">MSet</a>.  <a href="#abbf7ff734ff6adcb301e493f6eed803b"></a><br/></td></tr>
<tr class="memitem:a70bc7137850fe46d98e62c1020539d22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a70bc7137850fe46d98e62c1020539d22">set_cutoff</a> (int percent_cutoff, double weight_cutoff=0)</td></tr>
<tr class="memdesc:a70bc7137850fe46d98e62c1020539d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the percentage and/or weight cutoffs.  <a href="#a70bc7137850fe46d98e62c1020539d22"></a><br/></td></tr>
<tr class="memitem:a80a33a28791c05167204706c1a9d986b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a80a33a28791c05167204706c1a9d986b">set_sort_by_relevance</a> ()</td></tr>
<tr class="memdesc:a80a33a28791c05167204706c1a9d986b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sorting to be by relevance only.  <a href="#a80a33a28791c05167204706c1a9d986b"></a><br/></td></tr>
<tr class="memitem:ab10384fabd51eebd8174f916563e3f7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#ab10384fabd51eebd8174f916563e3f7a">set_sort_by_value</a> (<a class="el" href="namespaceXapian.html#a94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a> sort_key, bool reverse)</td></tr>
<tr class="memdesc:ab10384fabd51eebd8174f916563e3f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sorting to be by value only.  <a href="#ab10384fabd51eebd8174f916563e3f7a"></a><br/></td></tr>
<tr class="memitem:a0bcb7086d8633fc035c6e5d094e45d39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a0bcb7086d8633fc035c6e5d094e45d39">set_sort_by_key</a> (<a class="el" href="classXapian_1_1KeyMaker.html">Xapian::KeyMaker</a> *sorter, bool reverse)</td></tr>
<tr class="memdesc:a0bcb7086d8633fc035c6e5d094e45d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sorting to be by key generated from values only.  <a href="#a0bcb7086d8633fc035c6e5d094e45d39"></a><br/></td></tr>
<tr class="memitem:aa921b3c9386fbe2ddfd7dbbf130f9391"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#aa921b3c9386fbe2ddfd7dbbf130f9391">set_sort_by_value_then_relevance</a> (<a class="el" href="namespaceXapian.html#a94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a> sort_key, bool reverse)</td></tr>
<tr class="memdesc:aa921b3c9386fbe2ddfd7dbbf130f9391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sorting to be by value, then by relevance for documents with the same value.  <a href="#aa921b3c9386fbe2ddfd7dbbf130f9391"></a><br/></td></tr>
<tr class="memitem:a562beac4843f310dbdc61fdd33209be4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a562beac4843f310dbdc61fdd33209be4">set_sort_by_key_then_relevance</a> (<a class="el" href="classXapian_1_1KeyMaker.html">Xapian::KeyMaker</a> *sorter, bool reverse)</td></tr>
<tr class="memdesc:a562beac4843f310dbdc61fdd33209be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sorting to be by keys generated from values, then by relevance for documents with identical keys.  <a href="#a562beac4843f310dbdc61fdd33209be4"></a><br/></td></tr>
<tr class="memitem:a5a495760d5edc479385b14b463affbff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a5a495760d5edc479385b14b463affbff">set_sort_by_relevance_then_value</a> (<a class="el" href="namespaceXapian.html#a94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a> sort_key, bool reverse)</td></tr>
<tr class="memdesc:a5a495760d5edc479385b14b463affbff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sorting to be by relevance then value.  <a href="#a5a495760d5edc479385b14b463affbff"></a><br/></td></tr>
<tr class="memitem:ac64b07e06a24519baf1c495d0edcd0c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#ac64b07e06a24519baf1c495d0edcd0c3">set_sort_by_relevance_then_key</a> (<a class="el" href="classXapian_1_1KeyMaker.html">Xapian::KeyMaker</a> *sorter, bool reverse)</td></tr>
<tr class="memdesc:ac64b07e06a24519baf1c495d0edcd0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sorting to be by relevance, then by keys generated from values.  <a href="#ac64b07e06a24519baf1c495d0edcd0c3"></a><br/></td></tr>
<tr class="memitem:a27e8f3d6d784cce86059072d27ee4a66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a27e8f3d6d784cce86059072d27ee4a66">set_time_limit</a> (double time_limit)</td></tr>
<tr class="memdesc:a27e8f3d6d784cce86059072d27ee4a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a time limit for the match.  <a href="#a27e8f3d6d784cce86059072d27ee4a66"></a><br/></td></tr>
<tr class="memitem:a29e308dc81f66984af0a45c2a50eeafe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXapian_1_1ESet.html">ESet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a29e308dc81f66984af0a45c2a50eeafe">get_eset</a> (<a class="el" href="namespaceXapian.html#a4464380f6fa0055b5f26b8d03ae170e2">Xapian::termcount</a> maxitems, const <a class="el" href="classXapian_1_1RSet.html">RSet</a> &amp;omrset, int flags=0, const <a class="el" href="classXapian_1_1ExpandDecider.html">Xapian::ExpandDecider</a> *edecider=0, double min_wt=0.0) const </td></tr>
<tr class="memdesc:a29e308dc81f66984af0a45c2a50eeafe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the expand set for the given rset.  <a href="#a29e308dc81f66984af0a45c2a50eeafe"></a><br/></td></tr>
<tr class="memitem:af73e3672a3f1077309fbc99ef2db5412"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXapian_1_1ESet.html">ESet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#af73e3672a3f1077309fbc99ef2db5412">get_eset</a> (<a class="el" href="namespaceXapian.html#a4464380f6fa0055b5f26b8d03ae170e2">Xapian::termcount</a> maxitems, const <a class="el" href="classXapian_1_1RSet.html">RSet</a> &amp;omrset, const <a class="el" href="classXapian_1_1ExpandDecider.html">Xapian::ExpandDecider</a> *edecider) const </td></tr>
<tr class="memdesc:af73e3672a3f1077309fbc99ef2db5412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the expand set for the given rset.  <a href="#af73e3672a3f1077309fbc99ef2db5412"></a><br/></td></tr>
<tr class="memitem:ada8dca954912b004b599041f6d1043db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXapian_1_1ESet.html">ESet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#ada8dca954912b004b599041f6d1043db">get_eset</a> (<a class="el" href="namespaceXapian.html#a4464380f6fa0055b5f26b8d03ae170e2">Xapian::termcount</a> maxitems, const <a class="el" href="classXapian_1_1RSet.html">RSet</a> &amp;rset, int flags, double k, const <a class="el" href="classXapian_1_1ExpandDecider.html">Xapian::ExpandDecider</a> *edecider=NULL, double min_wt=0.0) const </td></tr>
<tr class="memdesc:ada8dca954912b004b599041f6d1043db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the expand set for the given rset.  <a href="#ada8dca954912b004b599041f6d1043db"></a><br/></td></tr>
<tr class="memitem:adda4181ccd15beb52c39f5e24adbb25b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#adda4181ccd15beb52c39f5e24adbb25b">get_matching_terms_begin</a> (<a class="el" href="namespaceXapian.html#ad8f7a78bc920532b7d2baa3281b33e2f">Xapian::docid</a> did) const </td></tr>
<tr class="memdesc:adda4181ccd15beb52c39f5e24adbb25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get terms which match a given document, by document id.  <a href="#adda4181ccd15beb52c39f5e24adbb25b"></a><br/></td></tr>
<tr class="memitem:a6a27b926405ef71ab138fa656dab0bd4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a27b926405ef71ab138fa656dab0bd4"></a>
<a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a6a27b926405ef71ab138fa656dab0bd4">get_matching_terms_end</a> (<a class="el" href="namespaceXapian.html#ad8f7a78bc920532b7d2baa3281b33e2f">Xapian::docid</a>) const </td></tr>
<tr class="memdesc:a6a27b926405ef71ab138fa656dab0bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">End iterator corresponding to <a class="el" href="classXapian_1_1Enquire.html#adda4181ccd15beb52c39f5e24adbb25b" title="Get terms which match a given document, by document id.">get_matching_terms_begin()</a> <br/></td></tr>
<tr class="memitem:a4d531a494be857ae09c831480ff651d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a4d531a494be857ae09c831480ff651d7">get_matching_terms_begin</a> (const <a class="el" href="classXapian_1_1MSetIterator.html">MSetIterator</a> &amp;it) const </td></tr>
<tr class="memdesc:a4d531a494be857ae09c831480ff651d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get terms which match a given document, by match set item.  <a href="#a4d531a494be857ae09c831480ff651d7"></a><br/></td></tr>
<tr class="memitem:a619e5a4f3597ed800e8f11190a5b7fe0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a619e5a4f3597ed800e8f11190a5b7fe0"></a>
<a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a619e5a4f3597ed800e8f11190a5b7fe0">get_matching_terms_end</a> (const <a class="el" href="classXapian_1_1MSetIterator.html">MSetIterator</a> &amp;) const </td></tr>
<tr class="memdesc:a619e5a4f3597ed800e8f11190a5b7fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">End iterator corresponding to <a class="el" href="classXapian_1_1Enquire.html#adda4181ccd15beb52c39f5e24adbb25b" title="Get terms which match a given document, by document id.">get_matching_terms_begin()</a> <br/></td></tr>
<tr class="memitem:a4a980eb2599afdf52ae78788849c9921"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a980eb2599afdf52ae78788849c9921"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a4a980eb2599afdf52ae78788849c9921">get_description</a> () const </td></tr>
<tr class="memdesc:a4a980eb2599afdf52ae78788849c9921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string describing this object. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aedb5fb761acc0bb2249bec375883a093"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXapian_1_1MSet.html">MSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#aedb5fb761acc0bb2249bec375883a093">get_mset</a> (<a class="el" href="namespaceXapian.html#a9bbd62a8e56ea4619e4e59afb32aced6">Xapian::doccount</a> first, <a class="el" href="namespaceXapian.html#a9bbd62a8e56ea4619e4e59afb32aced6">Xapian::doccount</a> maxitems, <a class="el" href="namespaceXapian.html#a9bbd62a8e56ea4619e4e59afb32aced6">Xapian::doccount</a> checkatleast=0, const <a class="el" href="classXapian_1_1RSet.html">RSet</a> *omrset=0, const <a class="el" href="classXapian_1_1MatchDecider.html">MatchDecider</a> *mdecider=0) const </td></tr>
<tr class="memdesc:aedb5fb761acc0bb2249bec375883a093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get (a portion of) the match set for the current query.  <a href="#aedb5fb761acc0bb2249bec375883a093"></a><br/></td></tr>
<tr class="memitem:ad53aba9cb5b62d14dce5395f568c050f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXapian_1_1MSet.html">MSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#ad53aba9cb5b62d14dce5395f568c050f">get_mset</a> (<a class="el" href="namespaceXapian.html#a9bbd62a8e56ea4619e4e59afb32aced6">Xapian::doccount</a> first, <a class="el" href="namespaceXapian.html#a9bbd62a8e56ea4619e4e59afb32aced6">Xapian::doccount</a> maxitems, const <a class="el" href="classXapian_1_1RSet.html">RSet</a> *omrset, const <a class="el" href="classXapian_1_1MatchDecider.html">MatchDecider</a> *mdecider=0) const </td></tr>
<tr class="memdesc:ad53aba9cb5b62d14dce5395f568c050f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get (a portion of) the match set for the current query.  <a href="#ad53aba9cb5b62d14dce5395f568c050f"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This class provides an interface to the information retrieval system for the purpose of searching. </p>
<p>Databases are usually opened lazily, so exceptions may not be thrown where you would expect them to be. You should catch <a class="el" href="classXapian_1_1Error.html" title="All exceptions thrown by Xapian are subclasses of Xapian::Error.">Xapian::Error</a> exceptions when calling any method in <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose of searching...">Xapian::Enquire</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API.">Xapian::InvalidArgumentError</a></td><td>will be thrown if an invalid argument is supplied, for example, an unknown database type. </td></tr>
  </table>
  </dd>
</dl>
</div><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5a5197e96345339874b2138264320256"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::Enquire::Enquire </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Database.html">Database</a> &amp;&#160;</td>
          <td class="paramname"><em>database</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose of searching...">Xapian::Enquire</a> object. </p>
<p>This specification cannot be changed once the <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose of searching...">Xapian::Enquire</a> is opened: you must create a new <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose of searching...">Xapian::Enquire</a> object to access a different database, or set of databases.</p>
<p>The database supplied must have been initialised (ie, must not be the result of calling the <a class="el" href="classXapian_1_1Database.html#a24f8197f3ac8bfd8c2526e0b8dff4ff7" title="Create a Database with no databases in.">Database::Database()</a> constructor). If you need to handle a situation where you have no databases gracefully, a database created with DB_BACKEND_INMEMORY can be passed here to provide a completely empty database.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">database</td><td>Specification of the database or databases to use. </td></tr>
    <tr><td class="paramname">errorhandler_</td><td>This parameter is deprecated (since <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a> 1.3.1), and as of 1.3.5 it's ignored completely.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API.">Xapian::InvalidArgumentError</a></td><td>will be thrown if an empty <a class="el" href="classXapian_1_1Database.html" title="This class is used to access a database, or a group of databases.">Database</a> object is supplied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="a43b54489c53d26a98d3fde3f1d3aa14f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::add_matchspy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1MatchSpy.html">MatchSpy</a> *&#160;</td>
          <td class="paramname"><em>spy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a matchspy. </p>
<p>This matchspy will be called with some of the documents which match the query, during the match process. Exactly which of the matching documents are passed to it depends on exactly when certain optimisations occur during the match process, but it can be controlled to some extent by setting the <em>checkatleast</em> parameter to <em><a class="el" href="classXapian_1_1Enquire.html#aedb5fb761acc0bb2249bec375883a093" title="Get (a portion of) the match set for the current query.">get_mset()</a></em>.</p>
<p>In particular, if there are enough matching documents, at least the number specified by <em>checkatleast</em> will be passed to the matchspy. This means that you can force the matchspy to be shown all matching documents by setting <em>checkatleast</em> to the number of documents in the database.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spy</td><td>The <a class="el" href="classXapian_1_1MatchSpy.html" title="Abstract base class for match spies.">MatchSpy</a> subclass to add. The caller must ensure that this remains valid while the <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose of searching...">Enquire</a> object remains active, or until <em><a class="el" href="classXapian_1_1Enquire.html#a1bb73406e3e7749a9e66ebc96ebd13f3" title="Remove all the matchspies.">clear_matchspies()</a></em> is called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a29e308dc81f66984af0a45c2a50eeafe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1ESet.html">ESet</a> Xapian::Enquire::get_eset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a4464380f6fa0055b5f26b8d03ae170e2">Xapian::termcount</a>&#160;</td>
          <td class="paramname"><em>maxitems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1RSet.html">RSet</a> &amp;&#160;</td>
          <td class="paramname"><em>omrset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1ExpandDecider.html">Xapian::ExpandDecider</a> *&#160;</td>
          <td class="paramname"><em>edecider</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_wt</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the expand set for the given rset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxitems</td><td>the maximum number of items to return. </td></tr>
    <tr><td class="paramname">omrset</td><td>the relevance set to use when performing the expand operation. </td></tr>
    <tr><td class="paramname">flags</td><td>zero or more of these values |-ed together:<ul>
<li>Xapian::Enquire::INCLUDE_QUERY_TERMS query terms may be returned from expand</li>
<li>Xapian::Enquire::USE_EXACT_TERMFREQ for multi dbs, calculate the exact termfreq; otherwise an approximation is used which can greatly improve efficiency, but still returns good results. </li>
</ul>
</td></tr>
    <tr><td class="paramname">edecider</td><td>a decision functor to use to decide whether a given term should be put in the <a class="el" href="classXapian_1_1ESet.html" title="Class representing a list of search results.">ESet</a> </td></tr>
    <tr><td class="paramname">min_wt</td><td>the minimum weight for included terms</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classXapian_1_1ESet.html" title="Class representing a list of search results.">ESet</a> object containing the results of the expand.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API.">Xapian::InvalidArgumentError</a></td><td>See class documentation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af73e3672a3f1077309fbc99ef2db5412"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1ESet.html">ESet</a> Xapian::Enquire::get_eset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a4464380f6fa0055b5f26b8d03ae170e2">Xapian::termcount</a>&#160;</td>
          <td class="paramname"><em>maxitems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1RSet.html">RSet</a> &amp;&#160;</td>
          <td class="paramname"><em>omrset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1ExpandDecider.html">Xapian::ExpandDecider</a> *&#160;</td>
          <td class="paramname"><em>edecider</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the expand set for the given rset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxitems</td><td>the maximum number of items to return. </td></tr>
    <tr><td class="paramname">omrset</td><td>the relevance set to use when performing the expand operation. </td></tr>
    <tr><td class="paramname">edecider</td><td>a decision functor to use to decide whether a given term should be put in the <a class="el" href="classXapian_1_1ESet.html" title="Class representing a list of search results.">ESet</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classXapian_1_1ESet.html" title="Class representing a list of search results.">ESet</a> object containing the results of the expand.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API.">Xapian::InvalidArgumentError</a></td><td>See class documentation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ada8dca954912b004b599041f6d1043db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1ESet.html">ESet</a> Xapian::Enquire::get_eset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a4464380f6fa0055b5f26b8d03ae170e2">Xapian::termcount</a>&#160;</td>
          <td class="paramname"><em>maxitems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1RSet.html">RSet</a> &amp;&#160;</td>
          <td class="paramname"><em>rset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1ExpandDecider.html">Xapian::ExpandDecider</a> *&#160;</td>
          <td class="paramname"><em>edecider</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_wt</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the expand set for the given rset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxitems</td><td>the maximum number of items to return. </td></tr>
    <tr><td class="paramname">rset</td><td>the relevance set to use when performing the expand operation. </td></tr>
    <tr><td class="paramname">flags</td><td>zero or more of these values |-ed together:<ul>
<li>Xapian::Enquire::INCLUDE_QUERY_TERMS query terms may be returned from expand</li>
<li>Xapian::Enquire::USE_EXACT_TERMFREQ for multi dbs, calculate the exact termfreq; otherwise an approximation is used which can greatly improve efficiency, but still returns good results. </li>
</ul>
</td></tr>
    <tr><td class="paramname">k</td><td>the parameter k in the query expansion algorithm (default is 1.0) </td></tr>
    <tr><td class="paramname">edecider</td><td>a decision functor to use to decide whether a given term should be put in the <a class="el" href="classXapian_1_1ESet.html" title="Class representing a list of search results.">ESet</a></td></tr>
    <tr><td class="paramname">min_wt</td><td>the minimum weight for included terms</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classXapian_1_1ESet.html" title="Class representing a list of search results.">ESet</a> object containing the results of the expand.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API.">Xapian::InvalidArgumentError</a></td><td>See class documentation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adda4181ccd15beb52c39f5e24adbb25b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a> Xapian::Enquire::get_matching_terms_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#ad8f7a78bc920532b7d2baa3281b33e2f">Xapian::docid</a>&#160;</td>
          <td class="paramname"><em>did</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get terms which match a given document, by document id. </p>
<p>This method returns the terms in the current query which match the given document.</p>
<p>It is possible for the document to have been removed from the database between the time it is returned in an <a class="el" href="classXapian_1_1MSet.html" title="Class representing a list of search results.">MSet</a>, and the time that this call is made. If possible, you should specify an <a class="el" href="classXapian_1_1MSetIterator.html" title="Iterator over a Xapian::MSet.">MSetIterator</a> instead of a <a class="el" href="namespaceXapian.html#ad8f7a78bc920532b7d2baa3281b33e2f" title="A unique identifier for a document.">Xapian::docid</a>, since this will enable database backends with suitable support to prevent this occurring.</p>
<p>Note that a query does not need to have been run in order to make this call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">did</td><td>The document id for which to retrieve the matching terms.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator returning the terms which match the document. The terms will be returned (as far as this makes any sense) in the same order as the terms in the query. Terms will not occur more than once, even if they do in the query.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API.">Xapian::InvalidArgumentError</a></td><td>See class documentation. </td></tr>
    <tr><td class="paramname"><a class="el" href="classXapian_1_1DocNotFoundError.html" title="Indicates an attempt to access a document not present in the database.">Xapian::DocNotFoundError</a></td><td>The document specified could not be found in the database. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4d531a494be857ae09c831480ff651d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a> Xapian::Enquire::get_matching_terms_begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1MSetIterator.html">MSetIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get terms which match a given document, by match set item. </p>
<p>This method returns the terms in the current query which match the given document.</p>
<p>If the underlying database has suitable support, using this call (rather than passing a <a class="el" href="namespaceXapian.html#ad8f7a78bc920532b7d2baa3281b33e2f" title="A unique identifier for a document.">Xapian::docid</a>) will enable the system to ensure that the correct data is returned, and that the document has not been deleted or changed since the query was performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>The iterator for which to retrieve the matching terms.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator returning the terms which match the document. The terms will be returned (as far as this makes any sense) in the same order as the terms in the query. Terms will not occur more than once, even if they do in the query.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API.">Xapian::InvalidArgumentError</a></td><td>See class documentation. </td></tr>
    <tr><td class="paramname"><a class="el" href="classXapian_1_1DocNotFoundError.html" title="Indicates an attempt to access a document not present in the database.">Xapian::DocNotFoundError</a></td><td>The document specified could not be found in the database. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aedb5fb761acc0bb2249bec375883a093"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1MSet.html">MSet</a> Xapian::Enquire::get_mset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a9bbd62a8e56ea4619e4e59afb32aced6">Xapian::doccount</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a9bbd62a8e56ea4619e4e59afb32aced6">Xapian::doccount</a>&#160;</td>
          <td class="paramname"><em>maxitems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a9bbd62a8e56ea4619e4e59afb32aced6">Xapian::doccount</a>&#160;</td>
          <td class="paramname"><em>checkatleast</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1RSet.html">RSet</a> *&#160;</td>
          <td class="paramname"><em>omrset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1MatchDecider.html">MatchDecider</a> *&#160;</td>
          <td class="paramname"><em>mdecider</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get (a portion of) the match set for the current query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the first item in the result set to return. A value of zero corresponds to the first item returned being that with the highest score. A value of 10 corresponds to the first 10 items being ignored, and the returned items starting at the eleventh. </td></tr>
    <tr><td class="paramname">maxitems</td><td>the maximum number of items to return. If you want all matches, then you can pass the result of calling get_doccount() on the <a class="el" href="classXapian_1_1Database.html" title="This class is used to access a database, or a group of databases.">Database</a> object (though if you are doing this so you can filter results, you are likely to get much better performance by using <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a>'s match-time filtering features instead). You can pass 0 for maxitems which will give you an empty <a class="el" href="classXapian_1_1MSet.html" title="Class representing a list of search results.">MSet</a> with valid statistics (such as get_matches_estimated()) calculated without looking at any postings, which is very quick, but means the estimates may be more approximate and the bounds may be much looser. </td></tr>
    <tr><td class="paramname">checkatleast</td><td>the minimum number of items to check. Because the matcher optimises, it won't consider every document which might match, so the total number of matches is estimated. Setting checkatleast forces it to consider at least this many matches and so allows for reliable paging links. </td></tr>
    <tr><td class="paramname">omrset</td><td>the relevance set to use when performing the query. </td></tr>
    <tr><td class="paramname">mdecider</td><td>a decision functor to use to decide whether a given document should be put in the <a class="el" href="classXapian_1_1MSet.html" title="Class representing a list of search results.">MSet</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classXapian_1_1MSet.html" title="Class representing a list of search results.">Xapian::MSet</a> object containing the results of the query.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API.">Xapian::InvalidArgumentError</a></td><td>See class documentation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad53aba9cb5b62d14dce5395f568c050f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1MSet.html">MSet</a> Xapian::Enquire::get_mset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a9bbd62a8e56ea4619e4e59afb32aced6">Xapian::doccount</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a9bbd62a8e56ea4619e4e59afb32aced6">Xapian::doccount</a>&#160;</td>
          <td class="paramname"><em>maxitems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1RSet.html">RSet</a> *&#160;</td>
          <td class="paramname"><em>omrset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1MatchDecider.html">MatchDecider</a> *&#160;</td>
          <td class="paramname"><em>mdecider</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get (a portion of) the match set for the current query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the first item in the result set to return. A value of zero corresponds to the first item returned being that with the highest score. A value of 10 corresponds to the first 10 items being ignored, and the returned items starting at the eleventh. </td></tr>
    <tr><td class="paramname">maxitems</td><td>the maximum number of items to return. If you want all matches, then you can pass the result of calling get_doccount() on the <a class="el" href="classXapian_1_1Database.html" title="This class is used to access a database, or a group of databases.">Database</a> object (though if you are doing this so you can filter results, you are likely to get much better performance by using <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a>'s match-time filtering features instead). You can pass 0 for maxitems which will give you an empty <a class="el" href="classXapian_1_1MSet.html" title="Class representing a list of search results.">MSet</a> with valid statistics (such as get_matches_estimated()) calculated without looking at any postings, which is very quick, but means the estimates may be more approximate and the bounds may be much looser. </td></tr>
    <tr><td class="paramname">checkatleast</td><td>the minimum number of items to check. Because the matcher optimises, it won't consider every document which might match, so the total number of matches is estimated. Setting checkatleast forces it to consider at least this many matches and so allows for reliable paging links. </td></tr>
    <tr><td class="paramname">omrset</td><td>the relevance set to use when performing the query. </td></tr>
    <tr><td class="paramname">mdecider</td><td>a decision functor to use to decide whether a given document should be put in the <a class="el" href="classXapian_1_1MSet.html" title="Class representing a list of search results.">MSet</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classXapian_1_1MSet.html" title="Class representing a list of search results.">Xapian::MSet</a> object containing the results of the query.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API.">Xapian::InvalidArgumentError</a></td><td>See class documentation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="add445bf19315638cccbb6418e2ae0d42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a>&amp; Xapian::Enquire::get_query </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current query. </p>
<p>If called before <a class="el" href="classXapian_1_1Enquire.html#a1148d960120662e5543e2a2b12620318" title="Set the query to run.">set_query()</a>, this will return a default initialised <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> object. </p>

</div>
</div>
<a class="anchor" id="a117ee547f5908e952e2e72d5a986d3bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_collapse_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a>&#160;</td>
          <td class="paramname"><em>collapse_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a9bbd62a8e56ea4619e4e59afb32aced6">Xapian::doccount</a>&#160;</td>
          <td class="paramname"><em>collapse_max</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the collapse key to use for queries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collapse_key</td><td>value number to collapse on - at most one <a class="el" href="classXapian_1_1MSet.html" title="Class representing a list of search results.">MSet</a> entry with each particular value will be returned (default is <a class="el" href="namespaceXapian.html#a0a75ef120e641c77f703e60f595ffda2" title="Reserved value to indicate &quot;no valueno&quot;.">Xapian::BAD_VALUENO</a> which means no collapsing).</td></tr>
    <tr><td class="paramname">collapse_max</td><td>Max number of items with the same key to leave after collapsing (default 1).</td></tr>
  </table>
  </dd>
</dl>
<p>The <a class="el" href="classXapian_1_1MSet.html" title="Class representing a list of search results.">MSet</a> returned by <a class="el" href="classXapian_1_1Enquire.html#aedb5fb761acc0bb2249bec375883a093" title="Get (a portion of) the match set for the current query.">get_mset()</a> will have only the "best" (at most) <em>collapse_max</em> entries with each particular value of <em>collapse_key</em> ("best" being highest ranked - i.e. highest weight or highest sorting key).</p>
<p>An example use might be to create a value for each document containing an MD5 hash of the document contents. Then duplicate documents from different sources can be eliminated at search time by collapsing with <em>collapse_max</em> = 1 (it's better to eliminate duplicates at index time, but this may not be always be possible - for example the search may be over more than one <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a> database).</p>
<p>Another use is to group matches in a particular category (e.g. you might collapse a mailing list search on the Subject: so that there's only one result per discussion thread). In this case you can use get_collapse_count() to give the user some idea how many other results there are. And if you index the Subject: as a boolean term as well as putting it in a value, you can offer a link to a non-collapsed search restricted to that thread using a boolean filter. </p>

</div>
</div>
<a class="anchor" id="a70bc7137850fe46d98e62c1020539d22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_cutoff </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>percent_cutoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight_cutoff</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the percentage and/or weight cutoffs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">percent_cutoff</td><td>Minimum percentage score for returned documents. If a document has a lower percentage score than this, it will not appear in the <a class="el" href="classXapian_1_1MSet.html" title="Class representing a list of search results.">MSet</a>. If your intention is to return only matches which contain all the terms in the query, then it's more efficient to use Xapian::Query::OP_AND instead of Xapian::Query::OP_OR in the query than to use set_cutoff(100). (default 0 =&gt; no percentage cut-off). </td></tr>
    <tr><td class="paramname">weight_cutoff</td><td>Minimum weight for a document to be returned. If a document has a lower score that this, it will not appear in the <a class="el" href="classXapian_1_1MSet.html" title="Class representing a list of search results.">MSet</a>. It is usually only possible to choose an appropriate weight for cutoff based on the results of a previous run of the same query; this is thus mainly useful for alerting operations. The other potential use is with a user specified weighting scheme. (default 0 =&gt; no weight cut-off). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abbf7ff734ff6adcb301e493f6eed803b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_docid_order </td>
          <td>(</td>
          <td class="paramtype">docid_order&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the direction in which documents are ordered by document id in the returned <a class="el" href="classXapian_1_1MSet.html" title="Class representing a list of search results.">MSet</a>. </p>
<p>This order only has an effect on documents which would otherwise have equal rank. For a weighted probabilistic match with no sort value, this means documents with equal weight. For a boolean match, with no sort value, this means all documents. And if a sort value is used, this means documents with equal sort value (and also equal weight if ordering on relevance after the sort).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>This can be:<ul>
<li>Xapian::Enquire::ASCENDING docids sort in ascending order (default)</li>
<li>Xapian::Enquire::DESCENDING docids sort in descending order</li>
<li><p class="startli">Xapian::Enquire::DONT_CARE docids sort in whatever order is most efficient for the backend</p>
<p class="startli">Note: If you add documents in strict date order, then a boolean search - i.e. set_weighting_scheme(Xapian::BoolWeight()) - with set_docid_order(Xapian::Enquire::DESCENDING) is an efficient way to perform "sort by date, newest first", and with set_docid_order(Xapian::Enquire::ASCENDING) a very efficient way to perform "sort by date, oldest first". </p>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab6ee3bcb26e8a4974527805d9e85ea9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_expansion_scheme </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>eweightname_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>expand_k_</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the weighting scheme to use for expansion. </p>
<p>If you don't call this method, the default is as if you'd used:</p>
<p>get_expansion_scheme("trad");</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eweightname_</td><td>A string in lowercase specifying the name of the scheme to be used. The following schemes are currently available: "bo1" : The Bo1 scheme for query expansion. "trad" : The <a class="el" href="classXapian_1_1TradWeight.html" title="Xapian::Weight subclass implementing the traditional probabilistic formula.">TradWeight</a> scheme for query expansion. </td></tr>
    <tr><td class="paramname">expand_k_</td><td>The parameter required for <a class="el" href="classXapian_1_1TradWeight.html" title="Xapian::Weight subclass implementing the traditional probabilistic formula.">TradWeight</a> query expansion. A default value of 1.0 is used if none is specified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1148d960120662e5543e2a2b12620318"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_query </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a> &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a4464380f6fa0055b5f26b8d03ae170e2">Xapian::termcount</a>&#160;</td>
          <td class="paramname"><em>qlen</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the query to run. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>the new query to run. </td></tr>
    <tr><td class="paramname">qlen</td><td>the query length to use in weight calculations - by default the sum of the wqf of all terms is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0bcb7086d8633fc035c6e5d094e45d39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_sort_by_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1KeyMaker.html">Xapian::KeyMaker</a> *&#160;</td>
          <td class="paramname"><em>sorter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the sorting to be by key generated from values only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sorter</td><td>The functor to use for generating keys.</td></tr>
    <tr><td class="paramname">reverse</td><td>If true, reverses the sort order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a562beac4843f310dbdc61fdd33209be4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_sort_by_key_then_relevance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1KeyMaker.html">Xapian::KeyMaker</a> *&#160;</td>
          <td class="paramname"><em>sorter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the sorting to be by keys generated from values, then by relevance for documents with identical keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sorter</td><td>The functor to use for generating keys.</td></tr>
    <tr><td class="paramname">reverse</td><td>If true, reverses the sort order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a80a33a28791c05167204706c1a9d986b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_sort_by_relevance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the sorting to be by relevance only. </p>
<p>This is the default. </p>

</div>
</div>
<a class="anchor" id="ac64b07e06a24519baf1c495d0edcd0c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_sort_by_relevance_then_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1KeyMaker.html">Xapian::KeyMaker</a> *&#160;</td>
          <td class="paramname"><em>sorter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the sorting to be by relevance, then by keys generated from values. </p>
<p>Note that with the default BM25 weighting scheme parameters, non-identical documents will rarely have the same weight, so this setting will give very similar results to <a class="el" href="classXapian_1_1Enquire.html#a80a33a28791c05167204706c1a9d986b" title="Set the sorting to be by relevance only.">set_sort_by_relevance()</a>. It becomes more useful with particular BM25 parameter settings (e.g. BM25Weight(1,0,1,0,0)) or custom weighting schemes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sorter</td><td>The functor to use for generating keys.</td></tr>
    <tr><td class="paramname">reverse</td><td>If true, reverses the sort order of the generated keys. Beware that in 1.2.16 and earlier, the sense of this parameter was incorrectly inverted and inconsistent with the other set_sort_by_... methods. This was fixed in 1.2.17, so make that version a minimum requirement if this detail matters to your application. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a495760d5edc479385b14b463affbff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_sort_by_relevance_then_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a>&#160;</td>
          <td class="paramname"><em>sort_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the sorting to be by relevance then value. </p>
<p>Note that sorting by values uses a string comparison, so to use this to sort by a numeric value you'll need to store the numeric values in a manner which sorts appropriately. For example, you could use <a class="el" href="namespaceXapian.html#a29a741b4cda98e10ed5f2fc784039065" title="Convert a floating point number to a string, preserving sort order.">Xapian::sortable_serialise()</a> (which works for floating point numbers as well as integers), or store numbers padded with leading zeros or spaces, or with the number of digits prepended.</p>
<p>Note that with the default BM25 weighting scheme parameters, non-identical documents will rarely have the same weight, so this setting will give very similar results to <a class="el" href="classXapian_1_1Enquire.html#a80a33a28791c05167204706c1a9d986b" title="Set the sorting to be by relevance only.">set_sort_by_relevance()</a>. It becomes more useful with particular BM25 parameter settings (e.g. BM25Weight(1,0,1,0,0)) or custom weighting schemes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sort_key</td><td>value number to sort on.</td></tr>
    <tr><td class="paramname">reverse</td><td>If true, reverses the sort order of sort_key. Beware that in 1.2.16 and earlier, the sense of this parameter was incorrectly inverted and inconsistent with the other set_sort_by_... methods. This was fixed in 1.2.17, so make that version a minimum requirement if this detail matters to your application. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab10384fabd51eebd8174f916563e3f7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_sort_by_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a>&#160;</td>
          <td class="paramname"><em>sort_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the sorting to be by value only. </p>
<p>Note that sorting by values uses a string comparison, so to use this to sort by a numeric value you'll need to store the numeric values in a manner which sorts appropriately. For example, you could use <a class="el" href="namespaceXapian.html#a29a741b4cda98e10ed5f2fc784039065" title="Convert a floating point number to a string, preserving sort order.">Xapian::sortable_serialise()</a> (which works for floating point numbers as well as integers), or store numbers padded with leading zeros or spaces, or with the number of digits prepended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sort_key</td><td>value number to sort on.</td></tr>
    <tr><td class="paramname">reverse</td><td>If true, reverses the sort order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa921b3c9386fbe2ddfd7dbbf130f9391"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_sort_by_value_then_relevance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a>&#160;</td>
          <td class="paramname"><em>sort_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the sorting to be by value, then by relevance for documents with the same value. </p>
<p>Note that sorting by values uses a string comparison, so to use this to sort by a numeric value you'll need to store the numeric values in a manner which sorts appropriately. For example, you could use <a class="el" href="namespaceXapian.html#a29a741b4cda98e10ed5f2fc784039065" title="Convert a floating point number to a string, preserving sort order.">Xapian::sortable_serialise()</a> (which works for floating point numbers as well as integers), or store numbers padded with leading zeros or spaces, or with the number of digits prepended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sort_key</td><td>value number to sort on.</td></tr>
    <tr><td class="paramname">reverse</td><td>If true, reverses the sort order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a27e8f3d6d784cce86059072d27ee4a66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_time_limit </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time_limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a time limit for the match. </p>
<p>Matches with check_at_least set high can take a long time in some cases. You can set a time limit on this, after which check_at_least will be turned off.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time_limit</td><td>time in seconds after which to disable check_at_least (default: 0.0 which means no time limit)</td></tr>
  </table>
  </dd>
</dl>
<p>Limitations:</p>
<p>This feature is currently supported on platforms which support POSIX interval timers. Interaction with the remote backend when using multiple databases may have bugs. There's not currently a way to force the match to end after a certain time. </p>

</div>
</div>
<a class="anchor" id="ad5c72e6f34c5c2da5f0b8c79736704ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_weighting_scheme </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Weight.html">Weight</a> &amp;&#160;</td>
          <td class="paramname"><em>weight_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the weighting scheme to use for queries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">weight_</td><td>the new weighting scheme. If no weighting scheme is specified, the default is BM25 with the default parameters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xapian/<a class="el" href="enquire_8h.html">enquire.h</a></li>
</ul>
</div><!-- contents -->
<hr>
<address><small>
Documentation for Xapian (version 1.4.0).<br>
Generated on Sat Jun 25 2016 by
<a href="http://www.doxygen.org/">Doxygen 1.8.1.2</a>.
</small></address>
</body>
</html>
